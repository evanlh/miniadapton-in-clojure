(ns miniadapton  ^:nextjournal.clerk/no-cache
  (:require [nextjournal.clerk :as clerk]
            [clojure.pprint :as pp]
            [clojure.set :as set]))

;; ## Incremental Computation with MiniAdapton in Clojure
;; Good day, friends. Today, we're here to explore a paper on a system called MiniAdapton. Adapton is an incremental computation engine, [originally described here](http://adapton.org/). Incremental Computation is the process of only re-computing the parts of a computation graph that need to be recomputed when the inputs to the computation graph change. [MiniAdapton](https://arxiv.org/abs/1609.05337) is a compact version of Adapton in Scheme, & since adapted to many other languages. The 'mini' prefix in the paper is in reference to [miniKanren](http://minikanren.org/).

;; This is my attempt at a port of the system described in the MiniAdapton paper to Clojure. If all goes well, I hope to use the Clerk environment to better illustrate some of what's happening using visuals. As a port, I'll attempt to use standard Clojure idioms where possible, but since the paper is explicitly about making memoization safe in the presence of *mutation*-- and Clojure is obviously very big on *immutability*-- we should be prepared to deal with a few footguns....

;; My purpose here is to:
;; - Learn some Clojure, inside of the excellent Clerk live-programming environment
;; - Learn some of the differences between Scheme (the language of the paper) and Clojure
;; - Learn MiniAdapton and some things about incremental computation
;; - Share some of those learnings in as digestible a manner as possible.

;; Sidenote: The implementation of [cells on maria.cloud](https://www.maria.cloud/cells) is probably a much better starting place if you're totally new to Lisps and interested in a similar system.

;; ### MicroAdapton in Clojure


;; in the scheme source these are generated by define-record-type, but for
;; Clojure we need to declare them explicitly here, because otherwise
;; fields marked ^:volatile-mutable aren't accessible on the public
;; interface.
^{::clerk/visibility :fold ::clerk/viewer :hide-result}
(comment
  (defprotocol IAdapton
    (adapton-thunk [this])
    (adapton-thunk-set! [this th])
    (adapton-result [this])
    (adapton-result-set! [this res])
    (adapton-sub [this])
    (adapton-sub-set! [this s])
    (adapton-super [this])
    (adapton-super-set! [this s])
    (adapton-clean? [this])
    (adapton-clean?-set! [this c])
    )

  (deftype Adapton [^:volatile-mutable thunk
                    ^:volatile-mutable result
                    ^:volatile-mutable sub
                    ^:volatile-mutable super
                    ^:volatile-mutable clean?]
    IAdapton
    (adapton-thunk [this] (.thunk this))
    (adapton-thunk-set! [this th] (set! thunk th))
    (adapton-result [this] (.result this))
    (adapton-result-set! [this res] (set! result res))
    (adapton-sub [this] (.sub this))
    (adapton-sub-set! [this s] (set! sub s))
    (adapton-super [this] (.super this))
    (adapton-super-set! [this s] (set! super s))
    (adapton-clean? [this] (.clean? this))
    (adapton-clean?-set! [this c] (set! clean? c))
    ))

;; REDUX! We want to use atoms instead of the volatile-mutable deftype....
(defn ->Adapton [thunk result sub super clean?]
  (atom {:thunk thunk, :result result, :sub sub, :super super, :clean clean?}))

(defn adapton-thunk [a] (:thunk @a))
;; functions that end in a ! are a lisp convention that says "hey! I'm mutatin' here!"
(defn adapton-thunk-set! [a thunk] (reset! a (assoc @a :thunk thunk)))
(defn adapton-result [a] (:result @a))
(defn adapton-result-set! [a res] (reset! a (assoc @a :result res)))
(defn adapton-sub [a] (:sub @a))
(defn adapton-sub-set! [a sub] (reset! a (assoc @a :sub sub)))
(defn adapton-super [a] (:super @a))
(defn adapton-super-set! [a super] (reset! a (assoc @a :super super)))
;; functions or vars that end in ? are a lisp convention indicating they're boolean
(defn adapton-clean? [a] (:clean @a))
(defn adapton-clean?-set! [a clean?] (reset! a (assoc @a :clean clean?)))

;; We want a custom visualizer anyway, but it turns out this is necessary even before
;; that because otherwise we can make Clerk stack overflow due to node's cyclic structure.
(clerk/add-viewers! [{:pred #(and (instance? clojure.lang.Atom %) (map? @%) (contains? @% :thunk))
                     :render-fn '#(v/html [:div.inline-block.rounded-sm.shadow (meta %)])}
                    ])

(def a (->Adapton nil nil #{} #{} false))
(adapton-thunk a)
(adapton-thunk-set! a (fn [] 1))
(adapton-clean? a)

(type @(->Adapton nil nil #{} #{} false))

;; To add a node to the directed compute graph we take the super node
;; `a-super`and the sub-node `a-sub`,
;; add the `a-sub` node to `a-super`'s sub Set, and
;; add the `a-super` node to `a-sub`'s super Set.
(defn adapton-add-dcg-edge! [a-super a-sub]
  (adapton-sub-set! a-super (conj (adapton-sub a-super) a-sub))
  (adapton-super-set! a-sub (conj (adapton-super a-sub) a-super)))

;; Deleting an edge in the compute graph is the same as above,
;; except removing (`disj`) from the sets instead of adding (`conj`)
(defn adapton-del-dcg-edge! [a-super a-sub]
  (adapton-sub-set! a-super (disj (adapton-sub a-super) a-sub))
  (adapton-super-set! a-sub (disj (adapton-super a-sub) a-super)))

;; Clojure is already winning us code brevity, since we can use the
;; native Set implementation instead of rolling our own like
;; they do in Appendix D in the original paper.
(defn make-athunk [thunk] (->Adapton thunk nil #{} #{} false))

(defn adapton-compute [a]
  (if (adapton-clean? a)
    (adapton-result a)
    (do
      (for [x (adapton-sub a)]
        (adapton-del-dcg-edge! a x))
      (adapton-clean?-set! a true)
      (adapton-result-set! a ((adapton-thunk a)))
      (adapton-compute a))))

(defn adapton-dirty! [a]
  (when (adapton-clean? a)
    (adapton-clean?-set! a false)
    (for [x (adapton-super a)]
      (adapton-dirty! x))))

;; Unlike in the Scheme implementation we made thunk's mutable as well
;; since there's no Clojure letrec equivalent for this implementation
;; of adapton-ref
(defn adapton-ref [val]
  (let [a (->Adapton nil
                     val
                     #{}
                     #{}
                     true)]
    (do (adapton-thunk-set! a (fn [] (adapton-result a)))
        a)))

(defn adapton-ref-set! [a val]
  (adapton-result-set! a val)
  (adapton-dirty! a))

;; Quick refresher: A `sub` computation is a computation with a dependency on another computation-- a `super` is the reverse, a computation that's depended on by a `sub`.
;; We're representing these dependencies in a graph which we can add
;; or remove edges from in the form of these Adapton nodes. (Every node models its in/out edges as a Set.)
;; Each of the nodes also contains a result, a thunk, and a clean? marker. From the paper:
;; - `thunk` - the computation to cache
;; - `result` - cached result of the computation
;; - `clean?` - whether or not the cached result is valid

;; The paper provides a test of this interface....
;; First we create two ref cells with values...
(def r1 (adapton-ref 8))
(def r2 (adapton-ref 10))

;; Then we create another cell using make-athunk...
;; ... which depends on both of the ref cells
;; and when invoked subtracts the new value of
;; r2 from r1
(def a
  (make-athunk (fn []
                 (adapton-add-dcg-edge! a r1)
                 (adapton-add-dcg-edge! a r2)
                 (- (adapton-compute r1)
                    (adapton-compute r2))
                 )))
;; Now we can compute the dependent cell `a`...
(adapton-compute a)
;; That looks right... Let's change the r1 ref and recompute...
(adapton-ref-set! r1 2)
(adapton-compute a)

;; w00t!
;; Actually, in Clerk this result doesn't print correctly... probably need to clear the cache?
;; Lol with no-cache prefix it prints the *new* value twice....
;; no-cache in the namespace doesn't seem to help much? it did for a minimal atom example

;; ### MiniAdapton in Clojure

;; #### adapton-force
;; > The essential interface to miniAdapton is `adapton-force`,
;; > a function that marks athunks as subcomputations if their
;; > computation occurs during the computation of a different athunk.

;; This little function is I think the coolest part of this whole design.
;; Basically, everytime you mark a variable as a dependency using this function,
;; it saves whether you're *currently* inside the scope of some other Adapton node,
;; marks the current node to the new dependency, adds link between the two to the graph,
;; and restores the previous dependency. During dependency computation of course you could
;; declare other dependencies recursively, so the process repeats, but because it always maintains a
;; reference to the previous node in the callstack you can go as deep as you want and it
;; will unwind properly. Short & sweet.
(def adapton-force
  (let [currently-adapting (atom false)]
    (fn [a]
      (let [prev-adapting @currently-adapting]
        (reset! currently-adapting a)
        (let [result (adapton-compute a)]
          (reset! currently-adapting prev-adapting)
          (when @currently-adapting
            (adapton-add-dcg-edge! @currently-adapting a))
          result)))))


;; This already cleans up a lot of what we were doing above...
(def r (adapton-ref 5))
(def a (make-athunk (fn [] (+ (adapton-force r) 3))))
(adapton-force a)

;; #### adapt macro
;; > A useful macro styled after delay takes expression and turns them into athunks

;; Clojure's `defmacro` form looks more like `defn` than the syntax-matching of
;; `defsyntax`. In particular, we don't need to account for the macro form itself.
;; It does involve a bit more quoting tho.
(defmacro adapt [expr]
  `(make-athunk (fn [] ~expr)))

;; The end result is cleaner syntax, now we can rewrite our earlier example using `adapt`:
(def b (adapt (+ (adapton-force r) 3)))
(adapton-force b)

;; #### define-amemo
;; Finally, we need to work up to defining the `define-amemo` macro...

;; > The first function produces memoized functions returning athunks
;;
;; Another win for Clojure's standard library, we can use the native `memoize` function
(defn adapton-memoize-lazy [f]
  (memoize (fn [x] (adapt (apply f x)))))

;; > `adapton-memoize` operates by taking the result of `adapton-memoize-lazy` and making a new function equivalent except that it returns the result of forcing the athunk instead of the athunk itself.
(defn adapton-memoize [f]
  (let [f* (adapton-memoize-lazy f)]
    (fn [x] (adapton-force (apply f* x)))))

;; we'll call these fn-amemo-1 since `fn` is the Clojure `lambda` equivalent
;; TODO ... actually, the fn macro is fairly complex and I got stuck on this part for a while.
;; Let's punt on this and come back to it. It doesn't seem too painful for a user to simply
;; call (def name (adapton-memoize (fn ...))) or (adapton-memoize (fn ...)) in the interim..;; (defmacro fn-amemo-1 [& args])

;; #### AVars

;; > An avar is a variable representing an expression which can be changed
;; > and will remain from-scratch consistent with other changes. It is made of
;; > an `adapton-ref` that itself contains an athunk for the desired expression.
(defmacro def-avar [name expr]
  `(def ~name (adapton-ref (adapt ~expr))))

;; TODO why do we force twice?
(defn avar-get [v]
  (adapton-force (adapton-force v)))

(defmacro avar-set! [v expr]
  `(adapton-ref-set! ~v (adapt ~expr)))

;; Translating the above examples to avars...
(def-avar v1 2)
(def-avar v2 (+ (avar-get v1) 4))
(def-avar b (+ (avar-get v1) (avar-get v2)))
(avar-get b)
(avar-set! v1 10)
(avar-get b)

;; Again, when evaluated in the editor this looks good, but in Clerk the second result is returned twice....

;; This should work with other datatypes too of course. Like strings...
(do
  (def-avar firstname "Evan")
  (def-avar welcome (str "Welcome to MiniAdapton, " (avar-get firstname)))
  (avar-get welcome))
(do
  (avar-set! firstname "Jack")
  (avar-get welcome))

;; And sets....
(do
  (def-avar set1 #{:if :how :not :now :venn :be})
  (def-avar set2 #{:if :where :not :now :see :venn})
  (def-avar venn (set/intersection (avar-get set1) (avar-get set2)))
  (avar-get venn))
(do
  (avar-set! set1 #{:not :venn})
  (avar-get venn))

;; And because we're evaluating actual expressions in here we get something that
;; starts to look (a little!) like some sort of constraint system. Let's say we have two
;; points on a line, of course we can calculate the midpoint for a third point:
(do
  (def-avar x1 10)
  (def-avar x2 20)
  (def-avar midpoint (/ (+ (avar-get x1) (avar-get x2)) 2))
  (avar-get midpoint))
(do
  (avar-set! x2 -10)
  (avar-get midpoint))

;; Some misc observations:
;; - This is a lazy, "pull" model of incremental computation, which seems like it would influence where you can successfully use this. For example, it's harder to see this working well for interactive UIs unless they know to poll relavent variables. Could you de-lazify it, or mark certain variables as "outputs" that always flow thru immediately?

;; I hope you enjoyed this. You can find me on Twitter [@evanlh](https://twitter.com/evanlh).
